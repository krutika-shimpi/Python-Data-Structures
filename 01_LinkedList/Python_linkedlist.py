# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/162aP85keP99Y0ZBmowz-Rjl0rgxsqPhS

# Python: LinkedLists

1. Creating Node
2. Creating LinkedList
3. Printing LL
4. Appending
5. Popping
6. Prepending
7. Pop_first
8. Get index
9. Set value
10. Insert value
11. Removing a value
12. Reversing the LL
"""

# Let's write a node class to create nodes
class Node:
  # Define the node constructor which takes in a value as input
  def __init__(self, value):
    self.value = value
    self.next = None

# Let's write a class to create a LinkedList
class LinkedList:
  # Define the LinkedList constructor which takes in a value parameter and creates a new node
  def __init__(self, value):
    # We make use of the Node class to create new_node
    new_node = Node(value)
    # We set the head and tail to new_node as it is the only element in the linkedlist
    self.head = self.tail = new_node
    # Increment the length attribute by one as we have added one element to the list
    self.length = 1

  ######################### PRINT LIST #########################
  # Let's define a method to print the linkedlist
  def print_list(self):
    # Set the temp variable to head
    temp = self.head
    # We traverse the linkedlist until we reach None
    while temp is not None:
      # Print the value
      print(temp.value)
      # Set the temp to the next value
      temp = temp.next

  ######################### APPEND #########################
  # Lets define the append method
  def append_item(self, value):
    # Create the new node
    new_node = Node(value)
    # Check if the linked list is empty
    if self.head == None:
      # Assign head tail to the new node as it will be the first node
      self.head = self.tail = new_node

    else: # If the list contains elements
      # Connect the new node to the last element
      self.tail.next = new_node
      # Set the tail to last element
      self.tail = new_node
    self.length += 1
    return True

  ######################### POP #########################
  # Define the pop function to be able to work with LinkedList
  def pop(self):
    # Check if the LinkedList is empty and return None if it is
    if self.length == 0:
      return None
    # Define two variables to track the previous and current element of the LinkedList
    pre = self.head
    temp = self.head
    # Run a loop to check if the temp is not pointing to None
    while temp.next:
      # Progress the LinkedList while updating both temp and pre
      pre = temp
      temp = temp.next

    # Once reached the last but one position, Update the tail
    self.tail = pre
    # Set the next as None
    self.tail.next = None
    # Decrement the length by 1
    self.length -= 1
    # Check if the linkedlist has only 1 element then both head and tail should be pointing to None
    if self.length == 0:
      self.head = self.tail = None
    # Return the node that was removed
    return temp

  ######################### PREPEND #########################
  # Lets define the function for Prepend
  def prepend(self, value):
    # Create the node using the Node class we created earlier
    new_node = Node(value)
    # Check if the LinkedList is empty
    if self.length == 0:
      # Set the head and tail to new node
      self.head = self.tail = new_node

    else:
      # Otherwise add the new element at the front by setting next of new node to head
      new_node.next = self.head
      # Update the head to new node
      self.head = new_node
    # Increment the length
    self.length += 1
    return True

  ######################### POP FIRST #########################
  # Let's define the pop_first function
  def pop_first(self):
    # Check if the LinkedList was empty
    if self.length == 0:
      return None

    else:
      # Otherwise create a temp variable and assign to first element
      temp = self.head
      # Update the head to the second element
      self.head = self.head.next
      # Set the next of temp to None
      temp.next = None
      # Decrement the length by 1
      self.length -= 1
      # Check if the LinkedList has just one element
      if self.length == 0:
        # Set the head and tail to None
        self.head = self.tail = None
    # Return the node
    return temp

  ######################### GET INDEX #########################
  # Let's define a function for fetching the index
  def get(self, index):
    # Check if the index is out of bounds
    if index < 0 or index >= self.length:
      # Return None
      return None

    # Create a temp variable and set it to head
    temp = self.head
    #  Iterate through the list to get reach the desired index in the LinkedList
    for _ in range(index):
      temp = temp.next

    # Return the temp which points to required index
    return temp

  ######################### SET VALUE #########################
  # Let's define the set_value function
  def set_value(self, index, value):
    # Get the index of the element we want to replace using the get function
    temp = self.get(index)
    # If temp exists update the balue to the given value
    if temp:
      temp.value = value
      # If successful return true
      return True
    # Else return false
    return False

  ######################### INSERT VALUE #########################
  # Let's create a function to insert value
  def insert(self, index, value):
    # Check the index out of bounds conditin
    if index < 0 or index > self.length:
      return False

    # If the index provided is at the beginning call the prepend function
    if index == 0:
      return self.prepend(value)

    # If the index provided is the last index then call the append function
    if index == self.length:
      return self.append(value)

    # Create the new node
    new_node = Node(value)
    # Create the temp variable and position it at the previous index than specified where we want to insert the value
    temp = self.get(index - 1)
    # Set the next of new node to next of temp
    new_node.next = temp.next
    # Set the previous node to new node to establish the link
    temp.next = new_node
    # Increment the value
    self.length += 1
    return True

  ######################### REMOVE AN ITEM #########################
  # Let's create the remove function
  def remove(self, index):
    # Check the index out of bounds conditions
    if index < 0 or index >= self.length:
      return None

    # Check if the item to be removed is present in the front
    if index == 0:
      return self.pop_first()

    # Check if the index is pointing at end
    if index == self.length:
      return self.pop()

    # otherwise use variables prev and temp to keep track of the indexes
    else:
      # set the prev to an index before the specified index
      prev = self.get(index - 1)
      # set the temp to the specified index
      temp = prev.next
      # set the next of previous to next of temp
      prev.next = temp.next
      # Set the next of temp to none to break the link
      temp.next = None
      # decrement the length by 1
      self.length -= 1
      # return true if the operation was successful
      return temp

  ######################### REVERSE THE LIST #########################
  # Let's define the reverse function
  def reverse(self):
    # Check if list is empty
    if self.length == 0:
      return None
    # otherwise interchange the head and tail using temp
    temp = self.head
    self.head = self.tail
    self.tail = temp
    # Set the after to next of temp
    after = temp.next
    # Set the before to None
    before = None
    # Iterate through the LinkedList till the end
    for _ in range(self.length):
      # update the after as next of temp
      after = temp.next
      # Reverse the link by setting next of temp to before
      temp.next = before
      # Move the before forward
      before = temp
      # Move the temp forward
      temp = after